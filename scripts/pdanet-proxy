#!/bin/bash
# PDANet+ Proxy — routes HTTP/HTTPS traffic through PDANet+ HTTP proxy
# Supports WiFi hotspot (primary) and USB tether (fallback)
# Uses redsocks to transparently redirect via iptables
#
# Usage: pdanet-proxy start|stop|status
# Requires: redsocks, root (for iptables)

PROXY_IP="192.168.49.1"
PROXY_PORT="8000"
RELAY_PORT="12345"    # http-relay for plain HTTP (port 80)
CONNECT_PORT="12346"  # http-connect for HTTPS (port 443)
CONF="/tmp/redsocks-pdanet.conf"
PID="/tmp/redsocks-pdanet.pid"
DNS_BACKUP="/tmp/redsocks-dns-backup"

detect_interface() {
    local iface
    iface=$(ip -4 addr show | grep "192\.168\.49\." | awk '{print $NF}')
    if [ -n "$iface" ]; then
        echo "$iface"
        return 0
    fi
    return 1
}

check_reachable() {
    ping -c 1 -W 2 "$PROXY_IP" >/dev/null 2>&1
}

cleanup() {
    # Idempotent cleanup — safe to call multiple times
    # Remove ALL REDSOCKS references from OUTPUT (handles duplicates)
    while iptables -t nat -D OUTPUT -p tcp -j REDSOCKS 2>/dev/null; do :; done
    iptables -t nat -F REDSOCKS 2>/dev/null
    iptables -t nat -X REDSOCKS 2>/dev/null

    # Remove UDP DNS block
    while iptables -D OUTPUT -p udp --dport 53 ! -d 127.0.0.0/8 -j REJECT 2>/dev/null; do :; done

    # Kill any redsocks we started
    if [ -f "$PID" ]; then
        kill "$(cat "$PID")" 2>/dev/null
        rm -f "$PID"
    fi
    # Also kill by config path in case PID file was lost
    pkill -f "redsocks -c $CONF" 2>/dev/null
    rm -f "$CONF"

    # Restore DNS if we changed it
    if [ -f "$DNS_BACKUP" ]; then
        local iface
        iface=$(detect_interface)
        if [ -n "$iface" ]; then
            # Reset to DHCP-provided DNS
            resolvectl revert "$iface" 2>/dev/null
        fi
        rm -f "$DNS_BACKUP"
    fi
}

start_proxy() {
    if ! command -v redsocks >/dev/null 2>&1; then
        echo "ERROR: redsocks not installed. Run: sudo apt install redsocks"
        exit 1
    fi

    local iface
    iface=$(detect_interface)
    if [ -z "$iface" ]; then
        echo "ERROR: No PDANet interface found (no interface on 192.168.49.0/24)"
        echo "Connect to PDANet WiFi hotspot or plug in USB tether first."
        exit 1
    fi
    echo "Detected PDANet interface: $iface"

    if ! check_reachable; then
        echo "ERROR: $PROXY_IP not reachable on $iface"
        echo "Is PDANet+ running on your phone?"
        exit 1
    fi

    # Always clean up first (idempotent — handles stale state, duplicates)
    cleanup

    # Set Google DNS — PDANet gateway doesn't serve DNS
    # Save current DNS so we can restore on stop
    resolvectl dns "$iface" 2>/dev/null > "$DNS_BACKUP"
    resolvectl dns "$iface" 8.8.8.8 8.8.4.4
    echo "Set DNS to 8.8.8.8 / 8.8.4.4"

    # Write redsocks config — two instances:
    # 1. http-relay on RELAY_PORT for plain HTTP (rewrites request for proxy)
    # 2. http-connect on CONNECT_PORT for HTTPS (tunnels via CONNECT method)
    cat > "$CONF" <<EOF
base {
    log_debug = off;
    log_info = off;
    daemon = on;
    redirector = iptables;
}
redsocks {
    local_ip = 127.0.0.1;
    local_port = $RELAY_PORT;
    ip = $PROXY_IP;
    port = $PROXY_PORT;
    type = http-relay;
}
redsocks {
    local_ip = 127.0.0.1;
    local_port = $CONNECT_PORT;
    ip = $PROXY_IP;
    port = $PROXY_PORT;
    type = http-connect;
}
EOF

    redsocks -c "$CONF" -p "$PID"
    if [ $? -ne 0 ]; then
        echo "ERROR: redsocks failed to start"
        rm -f "$CONF"
        exit 1
    fi

    # Wait briefly for redsocks to bind
    sleep 0.3

    # Create iptables chain (fresh — cleanup already removed old one)
    iptables -t nat -N REDSOCKS

    # Skip local/private/VPN addresses
    iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN
    iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN
    iptables -t nat -A REDSOCKS -d 100.64.0.0/10 -j RETURN  # Tailscale CGNAT
    iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN
    iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN
    iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN
    iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN
    iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN
    iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN

    # DNS → http-connect (TCP DNS tunneled through proxy)
    iptables -t nat -A REDSOCKS -p tcp --dport 53 -j REDIRECT --to-ports "$CONNECT_PORT"
    # HTTP → http-relay (proper proxy request rewriting)
    iptables -t nat -A REDSOCKS -p tcp --dport 80 -j REDIRECT --to-ports "$RELAY_PORT"
    iptables -t nat -A REDSOCKS -p tcp --dport 8080 -j REDIRECT --to-ports "$RELAY_PORT"
    # HTTPS → http-connect (CONNECT tunnel)
    iptables -t nat -A REDSOCKS -p tcp --dport 443 -j REDIRECT --to-ports "$CONNECT_PORT"
    iptables -t nat -A REDSOCKS -p tcp --dport 8443 -j REDIRECT --to-ports "$CONNECT_PORT"

    # Activate
    iptables -t nat -A OUTPUT -p tcp -j REDSOCKS

    # Block outgoing UDP DNS — forces systemd-resolved to use TCP
    # (TCP DNS goes through redsocks → PDANet proxy handles resolution)
    iptables -A OUTPUT -p udp --dport 53 ! -d 127.0.0.0/8 -j REJECT

    echo "PDANet+ proxy started ($PROXY_IP:$PROXY_PORT via $iface)"
}

stop_proxy() {
    cleanup
    echo "PDANet+ proxy stopped"
}

check_status() {
    if [ -f "$PID" ]; then
        local pid
        pid=$(cat "$PID" 2>/dev/null)
        if [ -n "$pid" ] && [ -d "/proc/$pid" ]; then
            local iface
            iface=$(detect_interface)
            echo "running (${iface:-unknown interface})"
            exit 0
        else
            rm -f "$PID" 2>/dev/null
        fi
    fi
    echo "stopped"
    exit 1
}

case "$1" in
    start)  start_proxy ;;
    stop)   stop_proxy ;;
    status) check_status ;;
    *)      echo "Usage: pdanet-proxy start|stop|status"; exit 1 ;;
esac
